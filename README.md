# IKBO-65-24  В - XIII

## Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ).
## Спецификация УВМ

_Загрузка константы_
A          |     B
Биты 0—5   |     Биты 6—37
18         |     Константа

Размер команды: 5 байт. Операнд: поле B. Результат: регистр-аккумулятор.
Тест (A=18, B=216):
0x12, 0x36, 0x00, 0x00, 0x00

_Чтение значения из памяти_
A          |     B
Биты 0—5   |     Биты 6—34
47         |     Адрес

Размер команды: 5 байт. Операнд: значение в памяти по адресу, которым является поле B. Результат: регистр-аккумулятор.
Тест (A=47, B=995):
0xEF, 0xF8, 0x00, 0x00, 0x00

_Запись значения в память_
A          |     B
Биты 0—5   |     Биты 6—34
51         |     Адрес

Размер команды: 5 байт. Операнд: регистр-аккумулятор. Результат: значение в памяти по адресу, которым является поле B.
Тест (A=51, B=512):
0x33, 0x80, 0x00, 0x00, 0x00

_Унарная операция: bswap()_
A          |     B
Биты 0—5   |     Биты 6—34
30         |     Адрес

Размер команды: 5 байт. Операнд: регистр-аккумулятор. Результат: значение в памяти по адресу, которым является поле B.
Тест (A=30, B=512):
0x1E, 0x80, 0x00, 0x00, 0x00

# Этап 1. Перевод программы в промежуточное представление
Цель: создать CLI-приложение ассемблера. Реализовать разбор текстового
представления команд и трансляцию в промежуточное представление.
Требования:
1. Ассемблер должен принимать на вход аргументы командной строки:
– Путь к исходному файлу с текстом программы.
– Путь к двоичному файлу-результату.
– Режим тестирования.
2. Спроектировать человекочитаемый язык ассемблера, используя формат
YAML. Поддержать все команды спецификации УВМ.
3. Описать в документации (например, в README.md) спроектированный язык
ассемблера.

- [X] #_Загрузка константы_ записывает в память с адресом(adress)
    const: {
    value: 10,
    adress: 1
    }
- [X] #_Чтение значения из памяти_ записывает в регистр-аккумулятор
    read: {
    adress: 1
    }
- [X] #Запись значения в память_ записывает из регистра-аккумулятора
    write: {
    adress: 1
    }
- [X] #_Унарная операция: bswap()_ берёт значение из регистра-аккумулятора
    bswap: {
    }

4. Реализовать транслятор, который язык ассемблера преобразует во
внутреннее представление (например, список кортежей, объектов или
словарей).
5. (только для данного этапа) В режиме тестирования вывести на экран
внутреннее представление ассемблированной программы в формате полей и
значений, как в тесте из спецификации УВМ.
6. Создать программу для тестов, приведенных в спецификации УВМ.
Продемонстрировать, что ассемблер генерирует идентичные
последовательности полей и их значений.
7. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

# Этап 2. Формирование машинного кода
Цель: реализовать логику преобразования команд в их двоичное
представление.
Требования:
1. Реализовать транслятор из промежуточного в машинное представление.
2. Записать результат ассемблирования в двоичный выходной файл.
3. Вывести на экран размер двоичного файла в байтах.
4. В режиме тестирования вывести результат ассемблирования на экран в
байтовом формате, как в тесте из спецификации УВМ.
55
5. Создать файл на языке ассемблера, результат трансляции которого
соответствует всем тестовым байтовым последовательностям из
спецификации УВМ.
6. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

# Этап 3. Интерпретатор и операции с памятью
Цель: создать цикл интерпретации, реализовать модель памяти УВМ и
выполнить базовые команды.
Требования:
1. Интерпретатор должен принимать на вход аргументы командной строки:
– Путь к бинарному файлу с ассемблированной программой.
– Путь к файлу, куда будет сохранен дамп памяти после выполнения
программы.
– Диапазон адресов памяти для вывода дампа.
2. Для дампа с содержимым памяти должен использоваться формат XML.
3. Реализовать модель памяти УВМ (например, в виде массивов). Память
команд и память данных должны быть объединены.
4. Реализовать основной цикл интерпретатора: чтение команды из бинарного
файла, перевод команды в промежуточное представление, выполнение.
5. Реализовать команды загрузки константы, а также чтение и запись в память.
6. Написать и выполнить тестовую программу, которая копирует массив с
одного адреса на другой, чтобы проверить корректность работы.
7. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

# Этап 4. Реализация арифметико-логического устройства (АЛУ)
Цель: завершить реализацию интерпретатора, добавив поддержку
вычислительных операций.
Требования:
1. Реализовать выполнение команды bswap().
2. Для реализованной команды написать и выполнить тестовую программу,
которая демонстрирует корректные вычисления с сохранением результата в
память для проверки.
3. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

# Этап 5. Выполнение тестовой задачи
Цель: использовать разработанные ассемблер и интерпретатор для решения
тестовой задачи.
Требования:
1. Написать, скомпилировать и исполнить программу по тестовой задаче:
выполнить поэлементно команду bswap() над вектором длины 9. Результат
записать в новый вектор.
2. Создать три примера программ с вычислениями над различными данными.
Продемонстрировать, что дамп памяти соответствует требованиям задачи.
3. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.
